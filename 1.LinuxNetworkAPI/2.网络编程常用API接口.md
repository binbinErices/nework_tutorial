套接字（socket）是网络编程的一个关键概念，用于分布式环境中的跨主机进程间通信。套接字提供了一套标准接口，允许不同主机上的进程通过网络进行通信。

## 1.创建套接字

创建TCP和UDP的套接字代码如下：
```c
int fd = socket(AF_INET, SOCKET_STREAM, 0); // TCP套接字
int fd = socket(AF_INET, SOCKET_DGRAM, 0); // UDP套接字
```
## 2. 常用函数

### 2.1 bind函数用于绑定地址和端口
```c
struct sockaddr_in server_addr;
server_addr.sin_family = AF_INET;
server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
server_addr.sin_port = htons(20000);

int listen_fd = socket(AF_INET, SOCK_STREAM, 0);
int ret = bind(listen_fd, (struct sockaddr*)&server_addr, sizeof(server_addr)));
```
`sockaddr_in`结构体取名的历史典故：sockaddr：本质上是“socket address”的缩写，表示“套接字地址”。最通用的结构体是：
```c
struct sockaddr
{
    sa_family_t sa_family;   // 地址族，如 AF_INET, AF_INET6
    char sa_data[14];        // 协议地址 + 端口，固定长度
};

struct sockaddr_in
{
    uint16_t        sin_family; // 地址族（address Family）
    uint16_t        sin_port;   // 16位TCP/UDP端口号 网络字节序(NBO)
    struct in_addr  sin_addr;   // 32位IP地址 网络字节序(NBO)
    char            sin_zero[8];// 预留
};

struct in_addr
{
    __be32       s_addr; // 32位IPv4地址
};
```
这个是通用抽象基类（并非真正的 C 继承，只是所有协议都能强转到它）  
sockaddr_in：其中的 in 不是 “in/out” 的含义，而是指 Internet。
sockaddr_in 的全称是 “socket address, Internet”，专门为 IPv4（AF_INET）准备的结构。
对应的 IPv6 版本就是 sockaddr_in6。
sockaddr_un对应的是Unix Domain Socket（本地文件路径通信）
sockaddr_ll对应的是链路层Link Layer（AF_PACKET，原始以太网地址）  
那为什么不叫 sockaddr_ip4 呢？这是因为：在 1980s 早期 BSD 套接字 API 设计的时候，TCP/IP 协议栈是 DARPA Internet Protocol Suite，统一称 Internet family，所以取了 in。那时候还没 IPv6，也不流行“ip4/ip6”这种叫法。

### 2.2 listen函数，监听地址和端口

```c
/* Maximum queue length specifiable by listen.  */
#define SOMAXCONN	4096
int listen_fd = socket(AF_INET, SOCK_STREAM, 0);
int ret = listen(fd, SOMAXCONN);
```

### 2.3 accept函数，接收连接请求

```c
struct sockaddr_in recv_addr; // 客户端地址
socklen_t in_len = sizeof(struct sockaddr_in);
int sokcet_fd = accept(listen_fd, (struct_sockaddr*)&recv_addr, &in_len);
```

### 2.4 connect函数，发起连接请求

```c
int fd = socket(AF_INET, SOCK_STREAM, 0);
int ret = connect(fd, (struct_sockaddr*)&server_addr, sizeof(server_addr));
```

### 2.5 send函数，通过fd向对端发送数据

```c
std::string msg_data = "hello world";
int ret = send(fd, msg_data.c_str(), msg_data.length(), 0);
```

### 2.6 recv函数，通过socket_fd接收数据

```c
char buf[1024] = {0};
int count = recv(socket_fd, buffer, 1024, 0);
```

### 2.7 sendto函数，通过fd向server_addr直接发送数据

```c
std::string msg_data = "hello world";
int ret = sendto(fd, msg_data.c_str(), msg_data.length(), MSG_DONTWAIT, (struct sockaddr*)&server_addr, sizeof(server_addr));
```


### 2.8 recvfrom函数，通过sockfd接收来自recv_addr的数据

```c
char buf[1024];
struct sockaddr_in recv_addr;
socklen_t addrlen = sizeof(recv_addr);

ssize_t n = recvfrom(sockfd, buf, sizeof(buf), 0,
                     (struct sockaddr*)&recv_addr, &addrlen);
printf("Got %zd bytes from %s:%d\n",
       n, inet_ntoa(recv_addr.sin_addr), ntohs(recv_addr.sin_port));
```

## 3. 查看函数签名

如果在编程过程中忘记了某个函数的签名，Linux平台下可以通过man命令进行查询；比如现在想查询listen函数的使用：
**➜  ~ man 2 listen**
```bash
LISTEN(2)                                                  Linux Programmer's Manual                                                 LISTEN(2)

NAME
       listen - listen for connections on a socket

SYNOPSIS
       #include <sys/types.h>          /* See NOTES */
       #include <sys/socket.h>

       int listen(int sockfd, int backlog);

DESCRIPTION
       listen()  marks the socket referred to by sockfd as a passive socket, that is, as a socket that will be used to accept incoming connec‐
       tion requests using accept(2).

       The sockfd argument is a file descriptor that refers to a socket of type SOCK_STREAM or SOCK_SEQPACKET.

       The backlog argument defines the maximum length to which the queue of pending connections for sockfd may grow.  If a connection request
       arrives  when the queue is full, the client may receive an error with an indication of ECONNREFUSED or, if the underlying protocol sup‐
       ports retransmission, the request may be ignored so that a later reattempt at connection succeeds.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EADDRINUSE
              Another socket is already listening on the same port.

       EADDRINUSE
              (Internet domain sockets) The socket referred to by sockfd had not previously been bound to an address and, upon  attempting  to
              bind it to an ephemeral port, it was determined that all port numbers in the ephemeral port range are currently in use.  See the
              discussion of /proc/sys/net/ipv4/ip_local_port_range in ip(7).

       EBADF  The argument sockfd is not a valid file descriptor.

       ENOTSOCK
              The file descriptor sockfd does not refer to a socket.

       EOPNOTSUPP

```

在windows平台下查看函数签名：

Windows 也有类似 man 手册的帮助文档，早些年 Visual Studio 会自带一套离线的 MSDN 文档库，其优点就是不需要电脑联网，缺点是占磁盘空间比较大，内容陈旧; MSDN 是 **Microsoft Developer Network（微软开发者网络）**的缩写，曾是微软公司面向软件开发人员提供信息服务和技术文档的平台，涵盖技术教程、开发工具、编程技巧等资源。从2020年1月起，MSDN 已整合至 Microsoft Docs，并于2022年进一步整合至 Microsoft Learn，后者现为微软最新的面向开发者的学习和文档平台；通过`https://learn.microsoft.com/en-us/windows/win32/`网址在线查询，比如查询listen函数的用法：

![windows搜索界面](../res/img/network_api_windows1.png)

在上述页面的搜索框中输入 **listen** ，然后回车，得到一组搜索结果，我们选择我们需要的页面，打开链接：https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-listen 与简陋的 man 手册相比，MSDN 关于connect 函数的说明就比较详细了，大体也分为以下几部分：

1. **Syntax**， 即函数签名，函数的参数类型、个数和返回值；
2. **Parameters**，参数的用法详细说明；
3. **Return Value**， 函数的返回值说明，在返回值部分，还有如果函数调用失败详细的错误码说明信息；
4. **Remarks**，这部分就是该函数的详细用法说明，某些函数还会给出示例代码；
5. **Requirements**，这部分指的是要使用这个函数，操作系统的版本要求，代码需要引入的头文件和库文件（如果有的话）。
6. **See Also**， 这部分一般是一些相关函数和知识点的链接信息。

## 4. TCP通讯基本流程

不管多么复杂的服务器或客户端程序，其网络通信的基本原理一定如下所述：

对于服务器，其通信流程一般有如下步骤：
```sh
1. 调用 socket 函数创建 socket（侦听socket）
2. 调用 bind 函数 将 socket绑定到某个ip和端口的二元组上
3. 调用 listen 函数 开启侦听
4. 当有客户端请求连接上来后，调用 accept 函数接受连接，产生一个新的 socket（客户端 socket）
5. 基于新产生的 socket 调用 send 或 recv 函数开始与客户端进行数据交流
6. 通信结束后，调用 close 函数关闭侦听 socket
```

对于客户端，其通信流程一般有如下步骤：

```sh
1. 调用 socket函数创建客户端 socket
2. 调用 connect 函数尝试连接服务器
3. 连接成功以后调用 send 或 recv 函数开始与服务器进行数据交流
4. 通信结束后，调用 close 函数关闭侦听socket
```

## 5. 接口使用示例

### 5.1 服务端程序

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <errno.h>

#define BUFFER_SIZE 1024

int main(int argc, char* argv[])
{
    if (argc < 2)
    {
        printf("Usage: %s port\n", argv[0]);
        return -1;
    }

    uint16_t port = atoi(argv[1]);
    int listenfd;
    struct sockaddr_in address;
    char buffer[BUFFER_SIZE] = {0};
    int opt = 1;
    socklen_t addrlen = sizeof(address);

    // 1. 创建 socket
    if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
    {
        printf("socket failed, ec: %d, info: %s\n", errno, strerror(errno));
        exit(EXIT_FAILURE);
    }

    // 2. 设置端口复用
    if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0)
    {
        printf("setsockopt failed, ec: %d, info: %s\n", errno, strerror(errno));
        exit(EXIT_FAILURE);
    }

    // 3. 绑定地址和端口
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;  // 任意网卡
    address.sin_port = htons(port);

    if (bind(listenfd, (struct sockaddr*)&address, sizeof(address)) < 0)
    {
        printf("bind failed, ec: %d, info: %s\n", errno, strerror(errno));
        exit(EXIT_FAILURE);
    }

    // 4. 监听
    if (listen(listenfd, SOMAXCONN) < 0)
    {
        printf("listen failed, ec: %d, info: %s\n", errno, strerror(errno));
        exit(EXIT_FAILURE);
    }
    printf("Server listening on port %d...\n", port);

    while (true)
    {
        struct sockaddr_in clientaddr;
        socklen_t clientaddrlen = sizeof(clientaddr);
		// 5. 接受客户端连接
        int clientfd = accept(listenfd, (struct sockaddr *)&clientaddr, &clientaddrlen);
        if (clientfd != -1)
        {
			char recvBuf[32] = {0};
			// 6. 从客户端接受数据
			int ret = recv(clientfd, recvBuf, 32, 0);
			if (ret > 0)
			{
                printf("recv data from client %s:%d, data: %s\n",
                    inet_ntoa(clientaddr.sin_addr),
                    ntohs(clientaddr.sin_port),
                    recvBuf);
				// 7. 将收到的数据回弹给客户端
				ret = send(clientfd, recvBuf, strlen(recvBuf), 0);
				if (ret != strlen(recvBuf))
                    printf("send data error, ec: %d, info: %s\n", errno, strerror(errno));
                printf("send data to client successfully, data: %s\n", recvBuf);
			}
			else
			{
                printf("recv data error, ec: %d, info: %s\n", errno, strerror(errno));
			}

			close(clientfd);
        }
    }

	// 8.关闭侦听socket
	close(listenfd);
    return 0;
}
```

### 5.2 客户端程序

```cpp
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <iostream>
#include <string.h>

#define SEND_DATA  "Hello World"

int main(int argc, char* argv[])
{
    if (argc < 3)
    {
        printf("Usage: %s server port\n", argv[0]);
        return -1;
    }

    char* server_addr = argv[1];
    uint16_t server_port = atoi(argv[2]);

    //1.创建一个socket
    int clientfd = socket(AF_INET, SOCK_STREAM, 0);
    if (clientfd == -1)
    {
        std::cout << "create client socket error." << std::endl;
        return -1;
    }

    //2.连接服务器
    struct sockaddr_in serveraddr;
    serveraddr.sin_family = AF_INET;
    serveraddr.sin_addr.s_addr = inet_addr(server_addr);
    serveraddr.sin_port = htons(server_port);
    if (connect(clientfd, (struct sockaddr *)&serveraddr, sizeof(serveraddr)) == -1)
    {
        std::cout << "connect socket error." << std::endl;
        return -1;
    }

	//3. 向服务器发送数据
	int ret = send(clientfd, SEND_DATA, strlen(SEND_DATA), 0);
	if (ret != strlen(SEND_DATA))
	{
		std::cout << "send data error." << std::endl;
		return -1;
	}

	std::cout << "send data successfully, data: " << SEND_DATA << std::endl;

	//4. 从客户端收取数据
	char recvBuf[32] = {0};
	ret = recv(clientfd, recvBuf, 32, 0);
	if (ret > 0)
	{
		std::cout << "recv data successfully, data: " << recvBuf << std::endl;
	}
	else
	{
		std::cout << "recv data error, data: " << recvBuf << std::endl;
	}

	//5. 关闭socket
	close(clientfd);

    return 0;
}
```

在 Linux Shell 界面输入以下命令编译服务器端和客户端：

```sh
# 编译 tcp_server.cpp 生成可执行文件 tcp_server   
[root@localhost test]# g++ -g -o tcp_server tcp_server.cpp
# 编译 tcp_client.cpp 生成可执行文件 tcp_client
[root@localhost test]# g++ -g -o tcp_client tcp_client.cpp
```

接着，我们看下执行效果，先启动服务器程序：

```
[root@localhost test]# ./tcp_server 8089
```

再启动客户端程序：

```
[root@localhost test]# ./tcp_client 10.128.0.1 8089 
```

这个时候客户端输出：

```sh
send data successfully, data: Hello World
recv data successfully, data: Hello World

```

服务器端输出：

```sh
Server listening on port 12379...
recv data from client 58.246.14.154:16383, data: Hello World
send data to client successfully, data: Hello World
```
